<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="/lib/geo.ext.min.js" type="text/javascript" charset="UTF8"></script>
    <script src="/lib/geo.min.js"></script>
    <style>
        html{
            height: 100%;
        }
    </style>

</head>
<body style="height: 100%;">
<script>
var myMap;
$(function() {
    var mapOptions = {node: '#map',
                      zoom : 3,
                      center : [0.0, 0.0]},
        layer, d3Layer;
    myMap = geo.map(mapOptions);

    /// Resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);

    function resizeCanvas() {
      $('#map').width('100%');
      $('#map').height('100%');
      updateAndDraw($('#map').width(), $('#map').height());
    }

    function updateAndDraw(width, height) {
      myMap.resize(0, 0, width, height);
      myMap.draw();
    }

    function drawChoropleth(ren, svg) {
      var colorScale = d3.scale.category20b();
      var color = d3.scale.quantize()
                    .domain([0, 1])
                    .range(["#ffffd4",
                            "#fee391",
                            "#fec44f",
                            "#fe9929",
                            "#ec7014",
                            "#cc4c02",
                            "#8c2d04"
                           ]);

      var projection = d3.geo.mercator();
      // var path = d3.geo.path()
      //            .projection(projection);

      var path = d3.geo.path().projection(function (c) {
        var d = ren.worldToDisplay({
          x: c[0],
          y: c[1],
          z: 0
        });
        return [d.x, d.y];
      });

      d3.json("us-states.json", function(json) {
        //Merge the ag. data and GeoJSON
        //Loop through once for each ag. data value
        // for (var i = 0; i < data.length; i++) {
        //   //Grab state name
        //   var dataState = data[i].state;

        //   //Grab data value, and convert from string to float
        //   var dataValue = parseFloat(data[i].value);

          //Find the corresponding state inside the GeoJSON
          for (var j = 0; j < json.features.length; j++) {
            var jsonState = json.features[j].properties.name;
            // if (dataState == jsonState) {
              //Copy the data value into the JSON
              // json.features[j].properties.value = dataValue;
              //Stop looking through the JSON
              break;
            // }
          }
        // }

      svg.selectAll("path")
        .data(json.features)
        .enter()
        .append("path")
        .attr("d", path)
        .style("fill-opacity", 0.5)
        .style("fill", function(d) {
          // Get data value
          var value = d.properties.value;
          if (1) {
            //If value exists…
            return color(Math.random());
          } else {
            //If value is undefined…
           return "#ffff";
          }
        });
      });
    }

    resizeCanvas();
    layer = myMap.createLayer('osm');
    d3Layer = myMap.createLayer('feature', {renderer: 'd3Renderer'});
    drawChoropleth(d3Layer.renderer(), d3Layer.canvas());
    myMap.draw();

    $.get( "mmsa.json", function (mmsaData) {
      var stats = {};
      mmsaData = JSON.parse(mmsaData);

      $.get( "BRFSS_MMSA_2010.geojson", function (data) {
        data.forEach(function (mydata) {
          var stateCode = mmsaData[d.properties.MMSA_numbe];
          if (stats.hasOwnProperty(stateCode)) {
            stats[stateCode]["yes"] += mydata.properties.A868_1;
            stats[stateCode]["no"] += mydata.properties.A868_2;
          } else {
            stats[stateCode]["yes"] = mydata.properties.A868_1;
            stats[stateCode]["no"] = mydata.properties.A868_2;
          }
        });
        console.log(stats);

        myMap
          .createLayer('feature', {renderer: 'd3Renderer'})
            .createFeature("point", {selectionAPI: true})
              .data(JSON.parse(data).features)
              .geoOn(geo.event.pointFeature.mouseover, function(d) {
                console.log(d.data.properties);
              })
              .style("fillOpacity", 0.6)
              .style("fillColor", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return {r: 163/255, g:227/255, b:110/255};
                }
                return {r: 170/255, g:92/255, b:57/255};
              })
              .style("radius", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return Math.ceil(parseFloat(d.properties.A868_1) * 0.2);
                }
                return Math.ceil(parseFloat(d.properties.A868_2) * 0.2);
              })
              .style("strokeWidth", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return Math.ceil(0.2 * parseFloat(d.properties.A868_2));
                }
                return Math.ceil(0.2 * parseFloat(d.properties.A868_1));
              })
              .style("strokeColor", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return {r: 170/255, g:92/255, b:57/255};
                }
                return {r: 163/255, g:227/255, b:110/255};
              })
              .position(function (d) {
                return {x: d.properties.LON, y: d.properties.LAT};
              });
        myMap.draw();
      });
    });
});
</script>

<div id='map'></div>
</body>

