<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="/lib/geo.ext.min.js" type="text/javascript" charset="UTF8"></script>
    <script src="/lib/geo.min.js"></script>
    <script src="histogram.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap-theme.min.css">

    <link href="main.css" rel="stylesheet">

</head>
<body>
<script>
var myMap;
$(function() {
    var mapOptions = {node: '#map',
                      zoom : 3,
                      center : [0.0, 0.0]},
        layer, d3Layer;
    myMap = geo.map(mapOptions);

    /// Resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);

    function resizeCanvas() {
      updateAndDraw($('#map').width(), $('#map').height());
    }

    function updateAndDraw(width, height) {
      myMap.resize(0, 0, width, height);
      myMap.draw();
    }

    function drawChoropleth(ren, svg) {
      var colorScale = d3.scale.category20b();
      var color = d3.scale.quantize()
                    .domain([0, 1])
                    .range(["#ffffd4",
                            "#fee391",
                            "#fec44f",
                            "#fe9929",
                            "#ec7014",
                            "#cc4c02",
                            "#8c2d04"
                           ]);

      var projection = d3.geo.mercator();
      // var path = d3.geo.path()
      //            .projection(projection);

      var path = d3.geo.path().projection(function (c) {
        var d = ren.worldToDisplay({
          x: c[0],
          y: c[1],
          z: 0
        });
        return [d.x, d.y];
      });

      d3.json("us-states.json", function(json) {
        //Merge the ag. data and GeoJSON
        //Loop through once for each ag. data value
        // for (var i = 0; i < data.length; i++) {
        //   //Grab state name
        //   var dataState = data[i].state;

        //   //Grab data value, and convert from string to float
        //   var dataValue = parseFloat(data[i].value);

          //Find the corresponding state inside the GeoJSON
          for (var j = 0; j < json.features.length; j++) {
            var jsonState = json.features[j].properties.name;
            // if (dataState == jsonState) {
              //Copy the data value into the JSON
              // json.features[j].properties.value = dataValue;
              //Stop looking through the JSON
              break;
            // }
          }
        // }

      svg.selectAll("path")
        .data(json.features)
        .enter()
        .append("path")
        .attr("d", path)
        .style("fill-opacity", 0.5)
        .style("fill", function(d) {
          // Get data value
          var value = d.properties.value;
          if (1) {
            //If value exists…
            return color(Math.random());
          } else {
            //If value is undefined…
           return "#ffff";
          }
        });
      });
    }

    resizeCanvas();
    layer = myMap.createLayer('osm');
    d3Layer = myMap.createLayer('feature', {renderer: 'd3Renderer'});
    drawChoropleth(d3Layer.renderer(), d3Layer.canvas());
    myMap.draw();

    $.get( "mmsa.json", function (mmsaData) {
      var stats = {};
      // mmsaData = JSON.parse(mmsaData);
      mmsaData = mmsaData.features;

      $.get( "BRFSS_MMSA_2010.geojson", function (data) {
        JSON.parse(data).features.forEach(function (mydata) {
          var stateCode = mmsaData[mydata.properties.MMSA_Numbe];
          // console.log(mydata.properties.MMSA_Numbe);
          if (stats.hasOwnProperty(stateCode)) {
            stats[stateCode]["yes"] += parseFloat(mydata.properties.A868_1);
            stats[stateCode]["no"] += parseFloat(mydata.properties.A868_2);
            stats[stateCode]["count"] += 1;
          } else {
            stats[stateCode] = {};
            stats[stateCode]["yes"] = parseFloat(mydata.properties.A868_1);
            stats[stateCode]["no"] = parseFloat(mydata.properties.A868_2);
            stats[stateCode]["count"] = 1;
          }
        });
        console.log(stats);
        var hisdata = [];
        for(var attr in stats){
          if (attr !== 'undefined') {
            console.log(attr);
            console.log(typeof attr);
            hisdata.push({state: attr,
                          yes: stats[attr].yes,
                          no:  stats[attr].no,
                          count: stats[attr].count});
          }
        }

        generateHistogram('#histogram', hisdata);

        myMap
          .createLayer('feature', {renderer: 'd3Renderer'})
            .createFeature("point", {selectionAPI: true})
              .data(JSON.parse(data).features)
              .geoOn(geo.event.pointFeature.mouseover, function(d) {
                console.log(d.data.properties);
              })
              .style("fillOpacity", 0.6)
              .style("fillColor", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return {r: 163/255, g:227/255, b:110/255};
                }
                return {r: 170/255, g:92/255, b:57/255};
              })
              .style("radius", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return Math.ceil(parseFloat(d.properties.A868_1) * 0.2);
                }
                return Math.ceil(parseFloat(d.properties.A868_2) * 0.2);
              })
              .style("strokeWidth", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return Math.ceil(0.2 * parseFloat(d.properties.A868_2));
                }
                return Math.ceil(0.2 * parseFloat(d.properties.A868_1));
              })
              .style("strokeColor", function (d) {
                if (parseFloat(d.properties.A868_1) > parseFloat(d.properties.A868_2)) {
                  return {r: 170/255, g:92/255, b:57/255};
                }
                return {r: 163/255, g:227/255, b:110/255};
              })
              .position(function (d) {
                return {x: d.properties.LON, y: d.properties.LAT};
              });
        myMap.draw();
      });
    });
});
</script>

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Mental Health GIS</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#about">About</a></li>
            <li><a href="#contact">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container-fluid">
      <div id='map'></div>
      <div id='histogram'></div>
    </div>
</body>

